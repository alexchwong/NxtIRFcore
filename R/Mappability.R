#' Creates a custom Mappability Exclusion BED file
#'
#' @description
#' These function create a custom Mappability Exclusion BED file from the 
#' supplied genome FASTA and gene annotation GTF file. 
#' 
#' @details Creating a Mappability Exclusion BED file is a three-step process.
#' \cr\cr
#' First, using `Mappability_GenReads()`,
#' reads are systematically generated by the given genome FASTA file 
#' (or the `reference_path` containing the genome resource).\cr\cr
#' Second, an aligner
#' such as STAR (preferably the same aligner used for the subsequent RNA-seq 
#' experiment) is required to align these reads to the source genome. Poorly
#' mapped regions of the genome will be reflected by regions of low coverage 
#' depth.\cr\cr
#' Finally, the BAM file containing the aligned reads is analysed 
#' using `Mappability_CalculateExclusions()`, to identify
#' low-mappability regions to compile the Mappability Exclusion BED file.
#' 
#' @param fasta_file The path to the user-supplied genome fasta file
#' @param reference_path The directory to store the reference files
#' @param read_len The nucleotide length of the generated reads
#' @param read_stride The nucleotide distance between sequentially generated
#'   reads
#' @param error_pos The position of the generated error within the reads
#' @param verbose Whether additional status messages are shown
#' @param aligned_bam The BAM file of reads (generated by 
#'   `Mappability_GenReads()`), aligned by the user using their
#'   aligner of choice.
#' @param threshold Regions with this read depth (or below) are defined as low
#'   mappability regions.
#' @param n_threads The number of threads used to calculate mappability
#'   exclusion regions from aligned bam file of synthetic reads.
#' @return None. `Mappability_GenReads()` writes `MappabilityReads.fa`
#'   to the given `reference_path`. `Mappability_CalculateExclusions()` writes
#'   its output BED file as named by `output_file` inside `reference_path`,
#'   appended by the ".txt" suffix. This BED file can be used as input
#'   as `MappabilityRef` in `BuildReference()`
#' @examples
#' 
#' # (1) Creates resource files and systematically generate reads based on
#' # the NxtIRF mock genome:
#' 
#' GetReferenceResource(
#'     reference_path = file.path(tempdir(), "Reference"),
#'     fasta = mock_genome(), gtf = mock_gtf()
#' )
#' Mappability_GenReads(
#'     reference_path = file.path(tempdir(), "Reference"),
#' )
#' 
#' \dontrun{
#' # Setting generate_mappability_reads = TRUE to GetReferenceResource() will
#' # run Mappability_GenReads after resource retrieval. The following code
#' is equivalent to that of above:
#' 
#' GetReferenceResource(
#'     reference_path = file.path(tempdir(), "Reference"),
#'     fasta = mock_genome(), gtf = mock_gtf(),
#'     generate_mappability_reads = TRUE
#' )
#' 
#' # (2) Align the generated reads using Rsubread:
#' 
#' setwd(file.path(tempdir(), "Reference"))
#' Rsubread::buildindex(basename = "./reference_index", 
#'     reference = mock_genome())
#' Rsubread::subjunc(
#'     index = "./reference_index", 
#'     readfile1 = "MappabilityReads.fa", 
#'     output_file = "MappabilityReads.bam", 
#'     useAnnotation = TRUE, 
#'     annot.ext = mock_gtf(), 
#'     isGTF = TRUE
#' )
#' 
#' # (3) Analyse the aligned reads for low-mappability regions:
#' 
#' Mappability_CalculateExclusions(aligned_bam = "MappabilityReads.bam",
#'     output_file = file.path(tempdir(), "Reference", "Mappability.bed")
#' )
#' }
#' @name Mappability-methods
#' @aliases 
#' Mappability_GenReads
#' Mappability_CalculateExclusions
#' @seealso [BuildReference]
#' <https://github.com/williamritchie/IRFinder/blob/master/bin/util/generateReadsError.pl>
#' @md
NULL

#' @describeIn Mappability-methods Generates synthetic reads from a 
#' genome FASTA file, for mappability calculations. 
#' This function replicates the functionality of generateReadsError.pl in 
#' vanilla IRFinder.
#' @export
Mappability_GenReads <- function(reference_path, fasta_file,
        read_len = 70, read_stride = 10, error_pos = 36,
        verbose = TRUE) {
    .gmr_check_params(read_len, read_stride, error_pos)
    if(missing(fasta_file)) {
        fasta_file = .STAR_get_FASTA(reference_path)
        if(!file.exists(fasta_file)) {
            .log(paste("In Mappability_GenReads,",
                "failed to generate genome fasta file from given reference"))
        }
    } else if(!file.exists(fasta_file)) {
        .log(paste("In Mappability_GenReads,",
            "given fasta file", fasta_file, "not found"))
    }
    .validate_path(file.path(normalizePath(reference_path), "Mappability"))
    # Run map read generator:
    outfile = file.path(normalizePath(reference_path), 
        "Mappability", "Reads.fa")
    .log(paste("Generating synthetic reads, saving to", outfile), "message")
    .run_IRFinder_GenerateMapReads(
        normalizePath(fasta_file), outfile,
        read_len, read_stride, error_pos
    )
    .STAR_clean_temp_FASTA_GTF(reference_path)
}

#' @describeIn Mappability-methods Generate a BED file defining 
#' low mappability regions, using reads generated by 
#' \code{Mappability_GenReads()}, aligned to the genome.
#' @export
Mappability_CalculateExclusions <- function(reference_path, 
        aligned_bam = file.path(reference_path, "Mappability", 
            "Aligned.out.bam"), 
        threshold = 4, n_threads = 1) {
    if(!file.exists(aligned_bam)) {
        .log(paste("In Mappability_CalculateExclusions(),",
            aligned_bam, "BAM file does not exist"))
    }

    .validate_path(file.path(normalizePath(reference_path), "Mappability"))
    output_file = file.path(normalizePath(reference_path), "Mappability",
        "MappabilityExclusion.bed")
        
    .log(paste("Calculating Mappability Exclusion regions from:",
        aligned_bam), type = "message")
    .run_IRFinder_MapExclusionRegions(
        bamfile = normalizePath(aligned_bam),
        output_file = output_file,
        threshold = threshold,
        n_threads = n_threads
    )
}

.gmr_check_params <- function(read_len, read_stride, error_pos) {
    if(!is.numeric(read_len) || read_len < 30) {
        .log(paste("In Mappability_GenReads,",
            "read_len must be numerical and at least 30"))
    }
    if(!is.numeric(read_stride) || read_stride > read_len) {
        .log(paste("In Mappability_GenReads,",
            "read_stride must be numerical and less than read_len"))
    }
    if(!is.numeric(error_pos) || error_pos > read_len) {
        .log(paste("In Mappability_GenReads,",
            "error_pos must be numerical and less than read_len"))
    }
}

.genmapreads_validate <- function(fasta, reference_path) {
    ah_genome = ""
    if (!dir.exists(dirname(reference_path))) {
        .log(paste("In Mappability_GenReads",
            dirname(reference_path), "does not exist"))
    }
    if(file.exists(fasta)) {
        if({
            tryCatch({
                genome = rtracklayer::import(fasta, "fasta")
                FALSE
            }, error = function(e) TRUE)
        }) {
            .log(paste("In Mappability_GenReads",
                fasta, "does not appear to be a valid FASTA file"))
        }
    } else {
        if (!file.exists(file.path(reference_path, "settings.Rds"))) {
            .log(paste("In Mappability_GenReads",
                "settings.Rds is not found.",
                "Run GetReferenceResource() first or supply a FASTA file"))
        }
        settings.Rds = readRDS(file.path(reference_path, "settings.Rds"))
        ah_genome = settings.Rds[["ah_genome"]]
        if (ah_genome != "" && substr(ah_genome, 1, 2) != "AH") {
            .log(paste("In Mappability_GenReads",
                ah_genome, "is not a valid AnnotationHub record name"))
        } else if(ah_genome == "" && !file.exists(
                file.path(reference_path, "resource", "genome.2bit"))) {
            .log(paste("In Mappability_GenReads",
                "resource/genome.2bit", "was not found in", reference_path,
                ". Perhaps run GetReferenceResource() again or supply",
                "a FASTA file"))
        }
    }
    if (!dir.exists(file.path(reference_path))) {
        dir.create(file.path(reference_path))
    }
    if (!dir.exists(file.path(reference_path, "resource"))) {
        dir.create(file.path(reference_path, "resource"))
    }
    return(ah_genome)
}

# Wrappers to native functions:

.run_IRFinder_GenerateMapReads = function(genome.fa = "", out.fa, 
    read_len = 70, read_stride = 10, error_pos = 36) {
    return(
        IRF_GenerateMappabilityReads(normalizePath(genome.fa), 
            file.path(normalizePath(dirname(out.fa)), basename(out.fa)),
            read_len = read_len, 
            read_stride = read_stride, 
            error_pos = error_pos)
    )
}

.run_IRFinder_MapExclusionRegions = function(bamfile = "", output_file, 
        threshold = 4, includeCov = FALSE, n_threads = 1) {
    s_bam = normalizePath(bamfile)
    if(!file.exists(s_bam)) {
        .log(paste("In run_IRFinder_MapExclusionRegions(),",
            s_bam, "does not exist"))
    }
    IRF_GenerateMappabilityRegions(s_bam, 
        output_file,
        threshold = threshold,
        includeCov = includeCov,
        verbose = TRUE, n_threads
    )
    # check file is actually made; then gzip it
    if(file.exists(paste0(output_file, ".txt"))) {
        R.utils::gzip(filename = paste0(output_file, ".txt"),
            destname = paste0(output_file, ".gz"))
    } else {
        .log(paste(paste0(output_file, ".txt"), "was not produced"))
    }
    return()
}



