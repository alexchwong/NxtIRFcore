



update_select_without_clearing <- function(session, inputId, choices, input) {
    req(inputId %in% names(input))
    selected = input[[inputId]]
    if(selected %in% choices) {
        updateSelectInput(session = session, inputId = inputId,
            choices = choices, selected = selected)
    } else {
        updateSelectInput(session = session, inputId = inputId,
            choices = choices, selected = selected)    
    }
}

get_psi <- function(se_path, 
        view_chr, view_start, view_end, view_strand = "*"
){
    junc_fst = file.path(se_path, "se", "junc_PSI.fst")
    junc_fst_index = file.path(se_path, "se", "junc_PSI_index.fst")
    if(!all(file.exists(c(junc_fst, junc_fst_index)))) {
        .log(paste("In get_psi(),",
            "Some junction fst files do not exist"))
    }
        
    junc_index = as.data.table(fst::read.fst(junc_fst_index)) 
    junc_index$index = seq_len(nrow(junc_index))
    junc_index = junc_index[
        seqnames == view_chr &
        start < view_end & end > view_start
    ]
    index_start = min(junc_index$index)
    index_end = max(junc_index$index)
    
    junc_index = as.data.table(fst::read.fst(junc_fst_index, 
        from = index_start, to = index_end))

    junc_data = as.matrix(fst::read.fst(junc_fst, 
        from = index_start, to = index_end))
    junc_data[is.na(junc_data)] = 0
    junc_data = as.data.table(junc_data)
    
    junc = cbind(junc_index, junc_data)
    junc = junc[
        seqnames == view_chr &
        start < view_end & end > view_start
    ]
    junc
}

update_data_frame <- function(existing_df, new_df) {
    # add extra samples to existing df
    DT1 = as.data.table(existing_df)
    DT2 = as.data.table(new_df)

    common_cols = intersect(names(DT1)[-1], names(DT2)[-1])
    new_cols = names(DT2)[!(names(DT2) %in% names(DT1))]

    if(!all(DT2$sample %in% DT1$sample)) {
        DT_add = DT2[!(sample %in% DT1$sample)]
        if(length(new_cols) > 0) DT_add = DT_add[, c(new_cols) := NULL]
        newDT = rbind(DT1, DT_add, fill = TRUE)
    } else {
        newDT = copy(DT1)
    }

    if(length(new_cols) > 0) {
        DT_tomerge = copy(DT2)
        if(length(common_cols) > 0) {
            DT_tomerge[, c(common_cols) := NULL]
        }
        newDT = merge(newDT, DT_tomerge, all = TRUE, by = "sample")
    }

    # now update conflicting values
    if(length(common_cols) > 0 & any(DT2$sample %in% DT1$sample)) {
        DT_toupdate = DT2[(sample %in% DT1$sample)]
        if(length(new_cols) > 0) {
            DT_toupdate = DT_toupdate[, c(new_cols) := NULL]
        }
        newDT[DT_toupdate, on = .(sample), 
            (common_cols) := mget(paste0("i.", common_cols))]
    }
    return(as.data.frame(newDT))
}

NxtIRF.SpliceCurve = function(xstart,xend,ystart,yend,y_height,info) {
    source.df = data.frame(
        xstart = xstart, xend = xend,
        ystart = ystart, yend = yend,
        y_height = y_height, info = info,
        stringsAsFactors = FALSE
    )
    final = c()
    for(i in seq_len(nrow(source.df))) {
        temp = with(source.df, 
            data.frame(info = info[i],
                x = seq(xstart[i],xend[i], length.out = 20),
                stringsAsFactors = FALSE)
            )
        temp$y = with(source.df, seq(ystart[i],yend[i], length.out = 20))
        temp$y = with(source.df, temp$y + 
            y_height[i] * sinpi((temp$x - xstart[i]) / (xend[i] - xstart[i]))
            )
        final = rbind(final, temp)
    }
    return(final)
}

#' Draws an arc plot representing the spliced reads of a given sample
#'
#' NB Experimental / WIP. Internal function only
#' @param fst_path The path to the output generated by [CollateData()]
#' @param seqnames,start,end,strand The region to display. `seqnames` and
#'   `strand` should be characters, whereas start and end should be integers
#' @param sample_name The sample name.
#' @return A ggplot object containing the rendered arc plot.
Plot_Junctions <- function(fst_path, 
        seqnames, start, end, strand, sample_name) {
    if(!file.exists(file.path(fst_path, "junc_counts.fst"))) {
        .log(paste("In Plot_Junctions(),",
            "The file", file.path(fst_path, "junc_counts.fst"), 
            "was not found"))
    }
    data = fst::read.fst(file.path(fst_path, "junc_counts.fst"))
    if(!(sample_name %in% colnames(data))) {
        .log(paste("In Plot_Junctions(),",
            sample_name, "was not a sample in the given data set"))
    }
    
    rownames(data) = data$rownames
    data$rownames = NULL
    
    index.gr = NxtIRF.CoordToGR(rownames(data))
    region.gr = GenomicRanges::GRanges(seqnames = seqnames, 
        ranges = IRanges::IRanges(start = start, end = end),
        strand = strand)
        
    OL = GenomicRanges::findOverlaps(index.gr, region.gr)
    data = data[sort(unique(OL@from)),sample_name, drop = FALSE]
    index = as.data.frame(index.gr[sort(unique(OL@from))])
    data = cbind(data, index)
    colnames(data)[1] = "sample"
    data = data[data$sample > 0,]

    df = NxtIRF.SpliceCurve(data$start, data$end, 0, 0,
        data$sample, rownames(data))
    y_range = max(df$y)
    
    data_mod = data
    data_mod$info = rownames(data)
    data_mod$x = ifelse(data_mod$start < start, start,
        ifelse(data_mod$end > end, end, (data_mod$start + data_mod$end) / 2))
    data_mod$start = ifelse(data_mod$start < start, start, data_mod$start)
    data_mod$end = ifelse(data_mod$end < end, end, data_mod$end)
    
    pl = ggplot() + 
        geom_line(data = df, 
            mapping = aes(
                x = get("x"), y = get("y"), 
                color = get("info"), group = get("info")
            )
        ) + geom_text(data = data_mod, mapping = aes(
            x = get("x"), y = get("sample"), label = get("sample")
        ), nudge_y = 0.05 * y_range) + theme_white
    return(pl)
}